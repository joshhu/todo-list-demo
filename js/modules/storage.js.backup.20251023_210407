/**
 * å„²å­˜æ¨¡çµ„
 *
 * è² è²¬ç®¡ç†æ‡‰ç”¨ç¨‹å¼çš„è³‡æ–™å„²å­˜ï¼ŒåŒ…æ‹¬ï¼š
 * - ä»»å‹™è³‡æ–™çš„ CRUD æ“ä½œ
 * - æœ¬åœ°å„²å­˜ç®¡ç†
 * - è³‡æ–™å‚™ä»½å’Œé‚„åŸ
 * - è³‡æ–™åŒæ­¥ï¼ˆæœªä¾†åŠŸèƒ½ï¼‰
 */

export class Storage {
  constructor(settings) {
    this.settings = settings;
    this.storageKey = 'todolist-tasks';
    this.tasks = [];
    this.listeners = new Map();
    this.lastModified = null;
  }

  /**
   * åˆå§‹åŒ–å„²å­˜æ¨¡çµ„
   */
  async initialize() {
    try {
      // è¼‰å…¥ä»»å‹™è³‡æ–™
      await this.loadTasks();

      // ç›£è½è¨­å®šè®Šæ›´
      this.settings.onChange('data.autoSave', (enabled) => {
        if (enabled) {
          this.startAutoSave();
        } else {
          this.stopAutoSave();
        }
      });

      // å•Ÿå‹•è‡ªå‹•å„²å­˜ï¼ˆå¦‚æœå·²å•Ÿç”¨ï¼‰
      if (this.settings.get('data.autoSave', true)) {
        this.startAutoSave();
      }

      console.log('âœ… å„²å­˜æ¨¡çµ„åˆå§‹åŒ–å®Œæˆ');
    } catch (error) {
      console.error('âŒ å„²å­˜æ¨¡çµ„åˆå§‹åŒ–å¤±æ•—:', error);
      throw error;
    }
  }

  /**
   * è¼‰å…¥ä»»å‹™è³‡æ–™
   */
  async loadTasks() {
    try {
      const savedTasks = localStorage.getItem(this.storageKey);
      if (savedTasks) {
        const parsed = JSON.parse(savedTasks);
        this.tasks = parsed.map(task => this.validateTask(task));
        this.lastModified = localStorage.getItem(`${this.storageKey}-last-modified`);
      } else {
        this.tasks = [];
        this.lastModified = null;
      }
    } catch (error) {
      console.warn('è¼‰å…¥ä»»å‹™å¤±æ•—ï¼Œä½¿ç”¨ç©ºä»»å‹™åˆ—è¡¨:', error);
      this.tasks = [];
      this.lastModified = null;
    }
  }

  /**
   * å„²å­˜ä»»å‹™è³‡æ–™
   */
  async saveTasks() {
    try {
      const dataToSave = JSON.stringify(this.tasks);
      localStorage.setItem(this.storageKey, dataToSave);

      const now = new Date().toISOString();
      localStorage.setItem(`${this.storageKey}-last-modified`, now);
      this.lastModified = now;

      this.settings.set('data.lastModified', now);
    } catch (error) {
      console.error('å„²å­˜ä»»å‹™å¤±æ•—:', error);
      throw error;
    }
  }

  /**
   * é©—è­‰ä»»å‹™è³‡æ–™
   * @param {Object} task - è¦é©—è­‰çš„ä»»å‹™
   * @returns {Object} é©—è­‰å¾Œçš„ä»»å‹™
   */
  validateTask(task) {
    const defaultTask = {
      id: '',
      title: '',
      description: '',
      priority: 'medium',
      status: 'pending',
      dueDate: null,
      tags: [],
      createdAt: null,
      updatedAt: null,
      completedAt: null
    };

    // åˆä½µé è¨­å€¼
    const validatedTask = { ...defaultTask, ...task };

    // ç¢ºä¿å¿…è¦æ¬„ä½å­˜åœ¨
    if (!validatedTask.id) {
      validatedTask.id = this.generateTaskId();
    }

    if (!validatedTask.createdAt) {
      validatedTask.createdAt = new Date().toISOString();
    }

    if (!validatedTask.updatedAt) {
      validatedTask.updatedAt = validatedTask.createdAt;
    }

    // ç¢ºä¿æ¨™é¡Œä¸ç‚ºç©º
    if (!validatedTask.title || validatedTask.title.trim() === '') {
      validatedTask.title = 'æœªå‘½åä»»å‹™';
    }

    // æ¸…ç†æ¨™é¡Œ
    validatedTask.title = validatedTask.title.trim();

    // ç¢ºä¿æ¨™ç±¤æ˜¯é™£åˆ—
    if (!Array.isArray(validatedTask.tags)) {
      validatedTask.tags = [];
    }

    // æ¸…ç†æ¨™ç±¤
    validatedTask.tags = validatedTask.tags
      .filter(tag => tag && typeof tag === 'string')
      .map(tag => tag.trim())
      .filter(tag => tag.length > 0);

    return validatedTask;
  }

  /**
   * ç”Ÿæˆä»»å‹™ ID
   * @returns {string} ä»»å‹™ ID
   */
  generateTaskId() {
    return `task_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * ç²å–æ‰€æœ‰ä»»å‹™
   * @returns {Array} ä»»å‹™é™£åˆ—
   */
  getTasks() {
    return [...this.tasks];
  }

  /**
   * æ ¹æ“š ID ç²å–ä»»å‹™
   * @param {string} id - ä»»å‹™ ID
   * @returns {Object|null} ä»»å‹™å°è±¡æˆ– null
   */
  getTask(id) {
    return this.tasks.find(task => task.id === id) || null;
  }

  /**
   * æ·»åŠ ä»»å‹™
   * @param {Object} taskData - ä»»å‹™è³‡æ–™
   * @returns {Object} æ–°å¢çš„ä»»å‹™
   */
  async addTask(taskData) {
    const newTask = this.validateTask({
      ...taskData,
      id: this.generateTaskId(),
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    });

    this.tasks.unshift(newTask); // æ·»åŠ åˆ°é–‹é ­

    try {
      await this.saveTasks();
      this.notifyListeners('taskAdded', newTask);
      return newTask;
    } catch (error) {
      // å›æ»¾è®Šæ›´
      this.tasks.shift();
      throw error;
    }
  }

  /**
   * æ›´æ–°ä»»å‹™
   * @param {string} id - ä»»å‹™ ID
   * @param {Object} updates - è¦æ›´æ–°çš„è³‡æ–™
   * @returns {Object|null} æ›´æ–°å¾Œçš„ä»»å‹™æˆ– null
   */
  async updateTask(id, updates) {
    const taskIndex = this.tasks.findIndex(task => task.id === id);
    if (taskIndex === -1) {
      return null;
    }

    const originalTask = this.tasks[taskIndex];
    const updatedTask = this.validateTask({
      ...originalTask,
      ...updates,
      updatedAt: new Date().toISOString()
    });

    this.tasks[taskIndex] = updatedTask;

    try {
      await this.saveTasks();
      this.notifyListeners('taskUpdated', updatedTask, originalTask);
      return updatedTask;
    } catch (error) {
      // å›æ»¾è®Šæ›´
      this.tasks[taskIndex] = originalTask;
      throw error;
    }
  }

  /**
   * åˆªé™¤ä»»å‹™
   * @param {string} id - ä»»å‹™ ID
   * @returns {boolean} æ˜¯å¦æˆåŠŸåˆªé™¤
   */
  async deleteTask(id) {
    const taskIndex = this.tasks.findIndex(task => task.id === id);
    if (taskIndex === -1) {
      return false;
    }

    const deletedTask = this.tasks[taskIndex];
    this.tasks.splice(taskIndex, 1);

    try {
      await this.saveTasks();
      this.notifyListeners('taskDeleted', deletedTask);
      return true;
    } catch (error) {
      // å›æ»¾è®Šæ›´
      this.tasks.splice(taskIndex, 0, deletedTask);
      throw error;
    }
  }

  /**
   * æ‰¹é‡åˆªé™¤ä»»å‹™
   * @param {Array} ids - ä»»å‹™ ID é™£åˆ—
   * @returns {number} æˆåŠŸåˆªé™¤çš„ä»»å‹™æ•¸é‡
   */
  async deleteTasks(ids) {
    const deletedTasks = [];
    const originalTasks = [...this.tasks];

    // æ¨™è¨˜è¦åˆªé™¤çš„ä»»å‹™
    this.tasks = this.tasks.filter(task => {
      if (ids.includes(task.id)) {
        deletedTasks.push(task);
        return false;
      }
      return true;
    });

    try {
      await this.saveTasks();
      deletedTasks.forEach(task => {
        this.notifyListeners('taskDeleted', task);
      });
      return deletedTasks.length;
    } catch (error) {
      // å›æ»¾è®Šæ›´
      this.tasks = originalTasks;
      throw error;
    }
  }

  /**
   * åˆ‡æ›ä»»å‹™å®Œæˆç‹€æ…‹
   * @param {string} id - ä»»å‹™ ID
   * @returns {Object|null} æ›´æ–°å¾Œçš„ä»»å‹™æˆ– null
   */
  async toggleTaskStatus(id) {
    const task = this.getTask(id);
    if (!task) {
      return null;
    }

    const newStatus = task.status === 'completed' ? 'pending' : 'completed';
    const updates = {
      status: newStatus,
      completedAt: newStatus === 'completed' ? new Date().toISOString() : null
    };

    return this.updateTask(id, updates);
  }

  /**
   * æ‰¹é‡æ›´æ–°ä»»å‹™ç‹€æ…‹
   * @param {Array} taskIds - ä»»å‹™ ID é™£åˆ—
   * @param {string} status - æ–°ç‹€æ…‹ ('pending' æˆ– 'completed')
   * @returns {Object} æ›´æ–°çµæœ
   */
  async batchUpdateTaskStatus(taskIds, status) {
    const results = {
      success: 0,
      failed: 0,
      errors: []
    };

    const originalTasks = this.tasks.map(task => ({ ...task }));

    try {
      for (const taskId of taskIds) {
        try {
          const task = this.getTask(taskId);
          if (task) {
            const updates = {
              status,
              completedAt: status === 'completed' ? new Date().toISOString() : null
            };

            const updatedTask = await this.updateTask(taskId, updates);
            if (updatedTask) {
              results.success++;

              // è¨˜éŒ„ç‹€æ…‹è®Šæ›´æ­·å²
              await this.recordStatusChange(taskId, task.status, status, new Date().toISOString());
            } else {
              results.failed++;
              results.errors.push(`ä»»å‹™ ${taskId} æ›´æ–°å¤±æ•—`);
            }
          } else {
            results.failed++;
            results.errors.push(`æ‰¾ä¸åˆ°ä»»å‹™ ${taskId}`);
          }
        } catch (error) {
          results.failed++;
          results.errors.push(`ä»»å‹™ ${taskId} æ›´æ–°å¤±æ•—: ${error.message}`);
        }
      }

      return results;
    } catch (error) {
      // å›æ»¾æ‰€æœ‰è®Šæ›´
      this.tasks = originalTasks;
      await this.saveTasks();
      throw error;
    }
  }

  /**
   * è¨˜éŒ„ç‹€æ…‹è®Šæ›´æ­·å²
   * @param {string} taskId - ä»»å‹™ ID
   * @param {string} fromStatus - åŸå§‹ç‹€æ…‹
   * @param {string} toStatus - æ–°ç‹€æ…‹
   * @param {string} changedAt - è®Šæ›´æ™‚é–“
   */
  async recordStatusChange(taskId, fromStatus, toStatus, changedAt) {
    const historyKey = `${this.storageKey}-status-history`;
    let history = [];

    try {
      const saved = localStorage.getItem(historyKey);
      if (saved) {
        history = JSON.parse(saved);
      }
    } catch (error) {
      console.warn('è¼‰å…¥ç‹€æ…‹æ­·å²å¤±æ•—:', error);
    }

    const changeRecord = {
      id: this.generateHistoryId(),
      taskId,
      fromStatus,
      toStatus,
      changedAt,
      timestamp: new Date(changedAt).getTime()
    };

    history.unshift(changeRecord);

    // é™åˆ¶æ­·å²è¨˜éŒ„æ•¸é‡ï¼ˆä¿ç•™æœ€è¿‘ 1000 æ¢ï¼‰
    if (history.length > 1000) {
      history = history.slice(0, 1000);
    }

    try {
      localStorage.setItem(historyKey, JSON.stringify(history));
    } catch (error) {
      console.warn('å„²å­˜ç‹€æ…‹æ­·å²å¤±æ•—:', error);
    }
  }

  /**
   * ç”Ÿæˆæ­·å²è¨˜éŒ„ ID
   * @returns {string} æ­·å²è¨˜éŒ„ ID
   */
  generateHistoryId() {
    return `history_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * ç²å–ç‹€æ…‹è®Šæ›´æ­·å²
   * @param {string} taskId - ä»»å‹™ IDï¼ˆå¯é¸ï¼‰
   * @param {Object} options - æŸ¥è©¢é¸é …
   * @returns {Array} ç‹€æ…‹è®Šæ›´æ­·å²
   */
  getStatusHistory(taskId = null, options = {}) {
    const { limit = 50, startDate = null, endDate = null } = options;
    const historyKey = `${this.storageKey}-status-history`;

    try {
      const saved = localStorage.getItem(historyKey);
      let history = saved ? JSON.parse(saved) : [];

      // ç¯©é¸ç‰¹å®šä»»å‹™
      if (taskId) {
        history = history.filter(record => record.taskId === taskId);
      }

      // ç¯©é¸æ—¥æœŸç¯„åœ
      if (startDate) {
        const start = new Date(startDate).getTime();
        history = history.filter(record => record.timestamp >= start);
      }

      if (endDate) {
        const end = new Date(endDate).getTime();
        history = history.filter(record => record.timestamp <= end);
      }

      // é™åˆ¶æ•¸é‡
      return history.slice(0, limit);
    } catch (error) {
      console.warn('è¼‰å…¥ç‹€æ…‹æ­·å²å¤±æ•—:', error);
      return [];
    }
  }

  /**
   * ç²å–ç‹€æ…‹çµ±è¨ˆ
   * @param {Object} options - çµ±è¨ˆé¸é …
   * @returns {Object} ç‹€æ…‹çµ±è¨ˆè³‡è¨Š
   */
  getStatusStatistics(options = {}) {
    const { period = 'all', startDate = null, endDate = null } = options;
    const history = this.getStatusHistory(null, { limit: 1000, startDate, endDate });

    const stats = {
      totalChanges: history.length,
      completedTasks: 0,
      uncompletedTasks: 0,
      changeRate: 0,
      averageCompletionTime: 0,
      dailyStats: {},
      hourlyStats: {}
    };

    // è¨ˆç®—å®Œæˆå’Œå–æ¶ˆå®Œæˆçš„æ¬¡æ•¸
    history.forEach(change => {
      if (change.toStatus === 'completed') {
        stats.completedTasks++;
      } else if (change.fromStatus === 'completed') {
        stats.uncompletedTasks++;
      }

      // æŒ‰æ—¥æœŸçµ±è¨ˆ
      const date = new Date(change.changedAt).toISOString().split('T')[0];
      if (!stats.dailyStats[date]) {
        stats.dailyStats[date] = { completed: 0, uncompleted: 0 };
      }

      if (change.toStatus === 'completed') {
        stats.dailyStats[date].completed++;
      } else if (change.fromStatus === 'completed') {
        stats.dailyStats[date].uncompleted++;
      }

      // æŒ‰å°æ™‚çµ±è¨ˆ
      const hour = new Date(change.changedAt).getHours();
      if (!stats.hourlyStats[hour]) {
        stats.hourlyStats[hour] = { completed: 0, uncompleted: 0 };
      }

      if (change.toStatus === 'completed') {
        stats.hourlyStats[hour].completed++;
      } else if (change.fromStatus === 'completed') {
        stats.hourlyStats[hour].uncompleted++;
      }
    });

    // è¨ˆç®—å¹³å‡å®Œæˆæ™‚é–“
    const completionTimes = this.calculateCompletionTimes(history);
    if (completionTimes.length > 0) {
      stats.averageCompletionTime = completionTimes.reduce((sum, time) => sum + time, 0) / completionTimes.length;
    }

    // è¨ˆç®—è®Šæ›´ç‡
    if (startDate && endDate) {
      const days = Math.ceil((new Date(endDate) - new Date(startDate)) / (1000 * 60 * 60 * 24));
      stats.changeRate = days > 0 ? Math.round((stats.totalChanges / days) * 10) / 10 : 0;
    }

    return stats;
  }

  /**
   * è¨ˆç®—ä»»å‹™å®Œæˆæ™‚é–“
   * @param {Array} history - ç‹€æ…‹è®Šæ›´æ­·å²
   * @returns {Array} å®Œæˆæ™‚é–“é™£åˆ—ï¼ˆæ¯«ç§’ï¼‰
   */
  calculateCompletionTimes(history) {
    const taskFirstSeen = new Map();
    const completionTimes = [];

    history.forEach(change => {
      if (change.fromStatus === 'pending' && change.toStatus === 'completed') {
        // è¨˜éŒ„å®Œæˆæ™‚é–“
        if (taskFirstSeen.has(change.taskId)) {
          const firstSeen = taskFirstSeen.get(change.taskId);
          const completionTime = new Date(change.changedAt).getTime() - firstSeen;
          completionTimes.push(completionTime);
          taskFirstSeen.delete(change.taskId);
        }
      } else if (change.fromStatus === null && change.toStatus === 'pending') {
        // è¨˜éŒ„ä»»å‹™é¦–æ¬¡å‰µå»ºæ™‚é–“
        taskFirstSeen.set(change.taskId, new Date(change.changedAt).getTime());
      }
    });

    return completionTimes;
  }

  /**
   * ç²å–è¿‘æœŸæ´»èºä»»å‹™
   * @param {number} days - å¤©æ•¸
   * @returns {Array} æ´»èºä»»å‹™åˆ—è¡¨
   */
  getActiveTasks(days = 7) {
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - days);
    const cutoffTimestamp = cutoffDate.getTime();

    const activeTasks = this.tasks.filter(task => {
      // æª¢æŸ¥ä»»å‹™æ˜¯å¦åœ¨è¿‘æœŸå…§æœ‰æ´»å‹•
      const createdAt = new Date(task.createdAt).getTime();
      const updatedAt = new Date(task.updatedAt).getTime();

      return createdAt >= cutoffTimestamp || updatedAt >= cutoffTimestamp;
    });

    // æŒ‰æœ€è¿‘æ´»å‹•æ™‚é–“æ’åº
    return activeTasks.sort((a, b) => {
      const aTime = Math.max(new Date(a.createdAt).getTime(), new Date(a.updatedAt).getTime());
      const bTime = Math.max(new Date(b.createdAt).getTime(), new Date(b.updatedAt).getTime());
      return bTime - aTime;
    });
  }

  /**
   * æ¸…ç†ç‹€æ…‹æ­·å²è¨˜éŒ„
   * @param {number} daysToKeep - ä¿ç•™å¤©æ•¸
   */
  async cleanupStatusHistory(daysToKeep = 90) {
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - daysToKeep);
    const cutoffTimestamp = cutoffDate.getTime();

    const historyKey = `${this.storageKey}-status-history`;
    try {
      const saved = localStorage.getItem(historyKey);
      if (saved) {
        const history = JSON.parse(saved);
        const filteredHistory = history.filter(record => record.timestamp >= cutoffTimestamp);

        localStorage.setItem(historyKey, JSON.stringify(filteredHistory));
        console.log(`ğŸ§¹ æ¸…ç†ç‹€æ…‹æ­·å²å®Œæˆï¼Œä¿ç•™ ${filteredHistory.length} æ¢è¨˜éŒ„`);
      }
    } catch (error) {
      console.warn('æ¸…ç†ç‹€æ…‹æ­·å²å¤±æ•—:', error);
    }
  }

  /**
   * ç²å–ä»»å‹™çµ±è¨ˆè³‡è¨Š
   * @returns {Object} çµ±è¨ˆè³‡è¨Š
   */
  getTaskStats() {
    const total = this.tasks.length;
    const completed = this.tasks.filter(task => task.status === 'completed').length;
    const pending = total - completed;

    const priorityStats = {
      high: this.tasks.filter(task => task.priority === 'high').length,
      medium: this.tasks.filter(task => task.priority === 'medium').length,
      low: this.tasks.filter(task => task.priority === 'low').length
    };

    const overdueTasks = this.tasks.filter(task => {
      return task.dueDate &&
             task.status !== 'completed' &&
             new Date(task.dueDate) < new Date();
    });

    return {
      total,
      completed,
      pending,
      completedPercentage: total > 0 ? Math.round((completed / total) * 100) : 0,
      priority: priorityStats,
      overdue: overdueTasks.length,
      lastModified: this.lastModified
    };
  }

  /**
   * æœå°‹ä»»å‹™
   * @param {Object} options - æœå°‹é¸é …
   * @returns {Array} ç¬¦åˆæ¢ä»¶çš„ä»»å‹™
   */
  searchTasks(options = {}) {
    const {
      query = '',
      status = null,
      priority = null,
      tags = [],
      dueDate = null,
      sortBy = 'created-desc',
      limit = null
    } = options;

    let filteredTasks = [...this.tasks];

    // æ–‡å­—æœå°‹
    if (query) {
      const searchQuery = query.toLowerCase();
      filteredTasks = filteredTasks.filter(task =>
        task.title.toLowerCase().includes(searchQuery) ||
        (task.description && task.description.toLowerCase().includes(searchQuery)) ||
        task.tags.some(tag => tag.toLowerCase().includes(searchQuery))
      );
    }

    // ç‹€æ…‹ç¯©é¸
    if (status) {
      if (status === 'active') {
        filteredTasks = filteredTasks.filter(task => task.status !== 'completed');
      } else if (status === 'completed') {
        filteredTasks = filteredTasks.filter(task => task.status === 'completed');
      } else {
        filteredTasks = filteredTasks.filter(task => task.status === status);
      }
    }

    // å„ªå…ˆç´šç¯©é¸
    if (priority) {
      filteredTasks = filteredTasks.filter(task => task.priority === priority);
    }

    // æ¨™ç±¤ç¯©é¸
    if (tags.length > 0) {
      filteredTasks = filteredTasks.filter(task =>
        tags.some(tag => task.tags.includes(tag))
      );
    }

    // æˆªæ­¢æ—¥æœŸç¯©é¸
    if (dueDate) {
      filteredTasks = filteredTasks.filter(task => {
        if (!task.dueDate) return false;
        const taskDueDate = new Date(task.dueDate).toDateString();
        const filterDate = new Date(dueDate).toDateString();
        return taskDueDate === filterDate;
      });
    }

    // æ’åº
    filteredTasks = this.sortTasks(filteredTasks, sortBy);

    // é™åˆ¶æ•¸é‡
    if (limit && limit > 0) {
      filteredTasks = filteredTasks.slice(0, limit);
    }

    return filteredTasks;
  }

  /**
   * æ’åºä»»å‹™
   * @param {Array} tasks - è¦æ’åºçš„ä»»å‹™é™£åˆ—
   * @param {string} sortBy - æ’åºæ–¹å¼
   * @returns {Array} æ’åºå¾Œçš„ä»»å‹™é™£åˆ—
   */
  sortTasks(tasks, sortBy) {
    const sorted = [...tasks];

    switch (sortBy) {
      case 'created-asc':
        return sorted.sort((a, b) => new Date(a.createdAt) - new Date(b.createdAt));

      case 'created-desc':
        return sorted.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));

      case 'updated-desc':
        return sorted.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));

      case 'updated-asc':
        return sorted.sort((a, b) => new Date(a.updatedAt) - new Date(b.updatedAt));

      case 'priority-desc':
        const priorityOrder = { high: 3, medium: 2, low: 1 };
        return sorted.sort((a, b) => priorityOrder[b.priority] - priorityOrder[a.priority]);

      case 'priority-asc':
        const priorityOrderAsc = { high: 3, medium: 2, low: 1 };
        return sorted.sort((a, b) => priorityOrderAsc[a.priority] - priorityOrderAsc[b.priority]);

      case 'due-date':
        return sorted.sort((a, b) => {
          if (!a.dueDate && !b.dueDate) return 0;
          if (!a.dueDate) return 1;
          if (!b.dueDate) return -1;
          return new Date(a.dueDate) - new Date(b.dueDate);
        });

      case 'title':
        return sorted.sort((a, b) => a.title.localeCompare(b.title, 'zh-TW'));

      default:
        return sorted;
    }
  }

  /**
   * ç²å–æ‰€æœ‰æ¨™ç±¤
   * @returns {Array} æ¨™ç±¤é™£åˆ—
   */
  getAllTags() {
    const tagSet = new Set();
    this.tasks.forEach(task => {
      task.tags.forEach(tag => tagSet.add(tag));
    });
    return Array.from(tagSet).sort();
  }

  /**
   * åŒ¯å‡ºä»»å‹™è³‡æ–™
   * @param {Array} taskIds - è¦åŒ¯å‡ºçš„ä»»å‹™ IDï¼Œå¦‚æœç‚ºç©ºå‰‡åŒ¯å‡ºæ‰€æœ‰ä»»å‹™
   * @returns {string} JSON æ ¼å¼çš„ä»»å‹™è³‡æ–™
   */
  exportTasks(taskIds = null) {
    const tasksToExport = taskIds
      ? this.tasks.filter(task => taskIds.includes(task.id))
      : this.tasks;

    return JSON.stringify({
      version: '1.0.0',
      exportedAt: new Date().toISOString(),
      tasks: tasksToExport,
      stats: this.getTaskStats()
    }, null, 2);
  }

  /**
   * åŒ¯å…¥ä»»å‹™è³‡æ–™
   * @param {string} tasksJson - JSON æ ¼å¼çš„ä»»å‹™è³‡æ–™
   * @param {Object} options - åŒ¯å…¥é¸é …
   * @returns {Object} åŒ¯å…¥çµæœ
   */
  async importTasks(tasksJson, options = {}) {
    const {
      overwrite = false,
      mergeTags = true
    } = options;

    try {
      const importedData = JSON.parse(tasksJson);
      const importedTasks = importedData.tasks || [];

      let importedCount = 0;
      let skippedCount = 0;
      let errorCount = 0;

      for (const taskData of importedTasks) {
        try {
          const validatedTask = this.validateTask(taskData);

          if (overwrite) {
            // è¦†è“‹æ¨¡å¼ï¼šå¦‚æœä»»å‹™å·²å­˜åœ¨å‰‡æ›´æ–°ï¼Œå¦å‰‡æ–°å¢
            const existingTask = this.getTask(validatedTask.id);
            if (existingTask) {
              await this.updateTask(validatedTask.id, validatedTask);
            } else {
              await this.addTask(validatedTask);
            }
          } else {
            // åˆä½µæ¨¡å¼ï¼šæ–°å¢æ‰€æœ‰ä»»å‹™ï¼ˆç”Ÿæˆæ–° IDï¼‰
            const { id, ...taskWithoutId } = validatedTask;
            await this.addTask(taskWithoutId);
          }

          importedCount++;
        } catch (error) {
          console.error('åŒ¯å…¥ä»»å‹™å¤±æ•—:', error);
          errorCount++;
        }
      }

      this.notifyListeners('tasksImported', {
        importedCount,
        skippedCount,
        errorCount,
        total: importedTasks.length
      });

      return {
        success: true,
        importedCount,
        skippedCount,
        errorCount,
        total: importedTasks.length
      };

    } catch (error) {
      console.error('åŒ¯å…¥ä»»å‹™è³‡æ–™å¤±æ•—:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }

  /**
   * æ¸…ç©ºæ‰€æœ‰ä»»å‹™
   */
  async clearAllTasks() {
    const originalTasks = [...this.tasks];
    this.tasks = [];

    try {
      await this.saveTasks();
      this.notifyListeners('allTasksCleared', originalTasks);
      return true;
    } catch (error) {
      // å›æ»¾è®Šæ›´
      this.tasks = originalTasks;
      throw error;
    }
  }

  /**
   * ç›£è½å„²å­˜äº‹ä»¶
   * @param {string} event - äº‹ä»¶åç¨±
   * @param {Function} callback - å›èª¿å‡½æ•¸
   * @returns {Function} å–æ¶ˆç›£è½çš„å‡½æ•¸
   */
  on(event, callback) {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, new Set());
    }

    this.listeners.get(event).add(callback);

    return () => {
      const eventListeners = this.listeners.get(event);
      if (eventListeners) {
        eventListeners.delete(callback);
        if (eventListeners.size === 0) {
          this.listeners.delete(event);
        }
      }
    };
  }

  /**
   * é€šçŸ¥äº‹ä»¶ç›£è½å™¨
   * @param {string} event - äº‹ä»¶åç¨±
   * @param {...*} args - äº‹ä»¶åƒæ•¸
   */
  notifyListeners(event, ...args) {
    if (this.listeners.has(event)) {
      this.listeners.get(event).forEach(callback => {
        try {
          callback(...args);
        } catch (error) {
          console.error(`å„²å­˜äº‹ä»¶ç›£è½å™¨åŸ·è¡Œå¤±æ•— (${event}):`, error);
        }
      });
    }
  }

  /**
   * é–‹å§‹è‡ªå‹•å„²å­˜
   */
  startAutoSave() {
    this.stopAutoSave(); // ç¢ºä¿æ²’æœ‰é‡è¤‡çš„å®šæ™‚å™¨

    const interval = this.settings.get('app.autoSaveInterval', 5000);
    this.autoSaveTimer = setInterval(() => {
      this.saveTasks().catch(error => {
        console.error('è‡ªå‹•å„²å­˜å¤±æ•—:', error);
      });
    }, interval);
  }

  /**
   * åœæ­¢è‡ªå‹•å„²å­˜
   */
  stopAutoSave() {
    if (this.autoSaveTimer) {
      clearInterval(this.autoSaveTimer);
      this.autoSaveTimer = null;
    }
  }

  /**
   * æ¸…ç†è³‡æº
   */
  destroy() {
    this.stopAutoSave();
    this.listeners.clear();
  }
}