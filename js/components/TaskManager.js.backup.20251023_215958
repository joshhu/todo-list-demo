/**
 * ä»»å‹™ç®¡ç†å™¨çµ„ä»¶
 * è² è²¬ä»»å‹™çš„å‰µå»ºã€é¡¯ç¤ºã€ç·¨è¼¯å’Œåˆªé™¤ç­‰ UI æ“ä½œ
 */

import taskService from '../services/TaskService.js';
import { EVENT_TYPES, APP_CONFIG, ERROR_MESSAGES, SUCCESS_MESSAGES } from '../config/settings.js';
import { dateUtils, stringUtils, domUtils, eventUtils, performanceUtils } from '../modules/utils.js';

/**
 * ä»»å‹™ç®¡ç†å™¨é¡åˆ¥
 */
class TaskManager {
    /**
     * å»ºæ§‹å‡½æ•¸
     */
    constructor(container) {
        this.container = container;
        this.currentFilter = 'all';
        this.editingTaskId = null;
        this.tasks = [];
        this.isLoading = false;
        this.searchTerm = '';
        this.sortBy = 'createdAt';
        this.sortOrder = 'desc';

        // ç¹«çµæ–¹æ³•
        this.handleTaskCreate = this.handleTaskCreate.bind(this);
        this.handleTaskUpdate = this.handleTaskUpdate.bind(this);
        this.handleTaskDelete = this.handleTaskDelete.bind(this);
        this.handleTaskToggle = this.handleTaskToggle.bind(this);
        this.handleFilterChange = this.handleFilterChange.bind(this);
        this.handleSearch = this.handleSearch.bind(this);
        this.handleSort = this.handleSort.bind(this);

        this.initialize();
    }

    /**
     * åˆå§‹åŒ–ä»»å‹™ç®¡ç†å™¨
     */
    async initialize() {
        try {
            // åˆå§‹åŒ–æœå‹™
            await taskService.initialize();

            // æ¸²æŸ“ UI
            this.render();

            // ç¹«çµäº‹ä»¶
            this.bindEvents();

            // ç›£è½æœå‹™äº‹ä»¶
            this.bindServiceEvents();

            // è¼‰å…¥ä»»å‹™
            await this.loadTasks();

            console.log('TaskManager åˆå§‹åŒ–å®Œæˆ');
        } catch (error) {
            console.error('TaskManager åˆå§‹åŒ–å¤±æ•—:', error);
            this.showError('åˆå§‹åŒ–å¤±æ•—', error.message);
        }
    }

    /**
     * æ¸²æŸ“ä¸»è¦ UI çµæ§‹ - ä½¿ç”¨å®‰å…¨çš„ DOM æ–¹æ³•
     */
    render() {
        // æ¸…ç©ºå®¹å™¨
        this.container.textContent = '';

        const taskManager = domUtils.createElement('div', { className: 'task-manager' });

        // ä»»å‹™è¼¸å…¥å€åŸŸ
        taskManager.appendChild(this.createInputSection());

        // ä»»å‹™çµ±è¨ˆ
        taskManager.appendChild(this.createStatsSection());

        // ä»»å‹™æ§åˆ¶å€åŸŸ
        taskManager.appendChild(this.createControlsSection());

        // ä»»å‹™åˆ—è¡¨
        taskManager.appendChild(this.createListSection());

        // é€šçŸ¥å®¹å™¨
        taskManager.appendChild(this.createNotificationContainer());

        this.container.appendChild(taskManager);
    }

    /**
     * å‰µå»ºè¼¸å…¥å€åŸŸ
     */
    createInputSection() {
        const section = domUtils.createElement('section', { className: 'task-input-section' });

        const title = domUtils.createElement('h2');
        title.textContent = 'æ–°å¢ä»»å‹™';
        section.appendChild(title);

        const form = domUtils.createElement('form', {
            id: 'task-form',
            className: 'task-form'
        });

        // æ¨™é¡Œè¼¸å…¥
        const titleGroup = domUtils.createElement('div', { className: 'form-group' });
        const titleInput = domUtils.createElement('input', {
            type: 'text',
            id: 'task-title',
            className: 'task-input',
            placeholder: 'è¼¸å…¥ä»»å‹™æ¨™é¡Œ...',
            maxLength: '200',
            required: '',
            'aria-label': 'ä»»å‹™æ¨™é¡Œ'
        });
        titleGroup.appendChild(titleInput);
        form.appendChild(titleGroup);

        // æè¿°å’Œå…¶ä»–è³‡æ–™è¡Œ
        const formRow = domUtils.createElement('div', { className: 'form-row' });

        // æè¿°
        const descGroup = domUtils.createElement('div', { className: 'form-group' });
        const descTextarea = domUtils.createElement('textarea', {
            id: 'task-description',
            className: 'task-textarea',
            placeholder: 'è¼¸å…¥ä»»å‹™æè¿°ï¼ˆé¸å¡«ï¼‰...',
            rows: '3',
            'aria-label': 'ä»»å‹™æè¿°'
        });
        descGroup.appendChild(descTextarea);
        formRow.appendChild(descGroup);

        // å„ªå…ˆç´š
        const priorityGroup = domUtils.createElement('div', { className: 'form-group' });
        const prioritySelect = domUtils.createElement('select', {
            id: 'task-priority',
            className: 'task-select',
            'aria-label': 'å„ªå…ˆç´š'
        });

        const priorities = [
            { value: 'low', text: 'ä½å„ªå…ˆç´š' },
            { value: 'medium', text: 'ä¸­å„ªå…ˆç´š' },
            { value: 'high', text: 'é«˜å„ªå…ˆç´š' }
        ];

        priorities.forEach(p => {
            const option = domUtils.createElement('option', { value: p.value });
            if (p.value === 'medium') option.selected = '';
            option.textContent = p.text;
            prioritySelect.appendChild(option);
        });
        priorityGroup.appendChild(prioritySelect);
        formRow.appendChild(priorityGroup);

        // æˆªæ­¢æ—¥æœŸ
        const dateGroup = domUtils.createElement('div', { className: 'form-group' });
        const dateInput = domUtils.createElement('input', {
            type: 'date',
            id: 'task-due-date',
            className: 'task-date',
            'aria-label': 'æˆªæ­¢æ—¥æœŸ'
        });
        dateGroup.appendChild(dateInput);
        formRow.appendChild(dateGroup);

        form.appendChild(formRow);

        // æ¨™ç±¤
        const tagsGroup = domUtils.createElement('div', { className: 'form-group' });
        const tagsInput = domUtils.createElement('input', {
            type: 'text',
            id: 'task-tags',
            className: 'task-input',
            placeholder: 'æ¨™ç±¤ï¼ˆç”¨é€—è™Ÿåˆ†éš”ï¼‰...',
            'aria-label': 'ä»»å‹™æ¨™ç±¤'
        });
        tagsGroup.appendChild(tagsInput);
        form.appendChild(tagsGroup);

        // æäº¤æŒ‰éˆ•
        const submitBtn = domUtils.createElement('button', {
            type: 'submit',
            className: 'btn btn-primary',
            id: 'add-task-btn'
        });
        submitBtn.innerHTML = '<span class="btn-icon">â•</span>æ–°å¢ä»»å‹™';
        form.appendChild(submitBtn);

        section.appendChild(form);
        return section;
    }

    /**
     * å‰µå»ºçµ±è¨ˆå€åŸŸ
     */
    createStatsSection() {
        const section = domUtils.createElement('section', { className: 'task-stats-section' });

        const statsContainer = domUtils.createElement('div', {
            id: 'task-stats',
            className: 'stats-container'
        });

        const stats = [
            { id: 'stat-total', label: 'ç¸½è¨ˆ' },
            { id: 'stat-active', label: 'é€²è¡Œä¸­' },
            { id: 'stat-completed', label: 'å·²å®Œæˆ' },
            { id: 'stat-overdue', label: 'é€¾æœŸ' }
        ];

        stats.forEach(stat => {
            const statItem = domUtils.createElement('div', { className: 'stat-item' });
            const statValue = domUtils.createElement('span', {
                id: stat.id,
                className: 'stat-value'
            });
            statValue.textContent = '0';
            const statLabel = domUtils.createElement('span', { className: 'stat-label' });
            statLabel.textContent = stat.label;

            statItem.appendChild(statValue);
            statItem.appendChild(statLabel);
            statsContainer.appendChild(statItem);
        });

        section.appendChild(statsContainer);
        return section;
    }

    /**
     * å‰µå»ºæ§åˆ¶å€åŸŸ
     */
    createControlsSection() {
        const section = domUtils.createElement('section', { className: 'task-controls-section' });

        const controlsContainer = domUtils.createElement('div', { className: 'controls-container' });

        // æœç´¢
        const searchContainer = domUtils.createElement('div', { className: 'search-container' });
        const searchInput = domUtils.createElement('input', {
            type: 'text',
            id: 'task-search',
            className: 'search-input',
            placeholder: 'æœç´¢ä»»å‹™...',
            'aria-label': 'æœç´¢ä»»å‹™'
        });
        searchContainer.appendChild(searchInput);
        controlsContainer.appendChild(searchContainer);

        // ç¯©é¸å™¨
        const filterContainer = domUtils.createElement('div', { className: 'filter-container' });
        const filters = [
            { text: 'å…¨éƒ¨', value: 'all', active: true },
            { text: 'é€²è¡Œä¸­', value: 'active' },
            { text: 'å·²å®Œæˆ', value: 'completed' }
        ];

        filters.forEach(filter => {
            const button = domUtils.createElement('button', {
                className: `filter-btn ${filter.active ? 'active' : ''}`,
                'data-filter': filter.value
            });
            button.textContent = filter.text;
            filterContainer.appendChild(button);
        });
        controlsContainer.appendChild(filterContainer);

        // æ’åº
        const sortContainer = domUtils.createElement('div', { className: 'sort-container' });
        const sortSelect = domUtils.createElement('select', {
            id: 'task-sort',
            className: 'sort-select',
            'aria-label': 'æ’åºæ–¹å¼'
        });

        const sortOptions = [
            { value: 'createdAt', text: 'å‰µå»ºæ™‚é–“' },
            { value: 'updatedAt', text: 'æ›´æ–°æ™‚é–“' },
            { value: 'priority', text: 'å„ªå…ˆç´š' },
            { value: 'dueDate', text: 'æˆªæ­¢æ—¥æœŸ' },
            { value: 'title', text: 'æ¨™é¡Œ' }
        ];

        sortOptions.forEach(option => {
            const optionElement = domUtils.createElement('option', { value: option.value });
            optionElement.textContent = option.text;
            sortSelect.appendChild(optionElement);
        });
        sortContainer.appendChild(sortSelect);

        const sortOrderBtn = domUtils.createElement('button', {
            id: 'sort-order-btn',
            className: 'sort-order-btn',
            title: 'åˆ‡æ›æ’åºé †åº'
        });
        sortOrderBtn.innerHTML = '<span class="sort-icon">â†“</span>';
        sortContainer.appendChild(sortOrderBtn);
        controlsContainer.appendChild(sortContainer);

        // æ‰¹é‡æ“ä½œ
        const batchActions = domUtils.createElement('div', { className: 'batch-actions' });

        const clearBtn = domUtils.createElement('button', {
            id: 'clear-completed-btn',
            className: 'btn btn-secondary'
        });
        clearBtn.textContent = 'æ¸…é™¤å·²å®Œæˆ';
        batchActions.appendChild(clearBtn);

        const exportBtn = domUtils.createElement('button', {
            id: 'export-btn',
            className: 'btn btn-secondary'
        });
        exportBtn.textContent = 'åŒ¯å‡º';
        batchActions.appendChild(exportBtn);

        const importLabel = domUtils.createElement('label', {
            for: 'import-file',
            className: 'btn btn-secondary'
        });
        importLabel.textContent = 'åŒ¯å…¥';
        batchActions.appendChild(importLabel);

        const importFile = domUtils.createElement('input', {
            type: 'file',
            id: 'import-file',
            accept: '.json',
            style: 'display: none;'
        });
        batchActions.appendChild(importFile);

        controlsContainer.appendChild(batchActions);
        section.appendChild(controlsContainer);
        return section;
    }

    /**
     * å‰µå»ºåˆ—è¡¨å€åŸŸ
     */
    createListSection() {
        const section = domUtils.createElement('section', { className: 'task-list-section' });

        const listContainer = domUtils.createElement('div', { className: 'list-container' });

        // è¼‰å…¥æŒ‡ç¤ºå™¨
        const loadingIndicator = domUtils.createElement('div', {
            id: 'loading-indicator',
            className: 'loading-indicator',
            style: 'display: none;'
        });
        const spinner = domUtils.createElement('div', { className: 'spinner' });
        const loadingText = domUtils.createElement('span');
        loadingText.textContent = 'è¼‰å…¥ä¸­...';
        loadingIndicator.appendChild(spinner);
        loadingIndicator.appendChild(loadingText);
        listContainer.appendChild(loadingIndicator);

        // ç©ºç‹€æ…‹
        const emptyState = domUtils.createElement('div', {
            id: 'empty-state',
            className: 'empty-state',
            style: 'display: none;'
        });
        const emptyIcon = domUtils.createElement('div', { className: 'empty-icon' });
        emptyIcon.textContent = 'ğŸ“';
        const emptyTitle = domUtils.createElement('h3');
        emptyTitle.textContent = 'å°šç„¡ä»»å‹™';
        const emptyText = domUtils.createElement('p');
        emptyText.textContent = 'é–‹å§‹æ–°å¢æ‚¨çš„ç¬¬ä¸€å€‹ä»»å‹™å§ï¼';

        emptyState.appendChild(emptyIcon);
        emptyState.appendChild(emptyTitle);
        emptyState.appendChild(emptyText);
        listContainer.appendChild(emptyState);

        // ä»»å‹™åˆ—è¡¨
        const taskList = domUtils.createElement('ul', {
            id: 'task-list',
            className: 'task-list',
            role: 'list'
        });
        listContainer.appendChild(taskList);

        section.appendChild(listContainer);
        return section;
    }

    /**
     * å‰µå»ºé€šçŸ¥å®¹å™¨
     */
    createNotificationContainer() {
        return domUtils.createElement('div', {
            id: 'notification-container',
            className: 'notification-container',
            role: 'status',
            'aria-live': 'polite'
        });
    }

    /**
     * ç¹«çµäº‹ä»¶
     */
    bindEvents() {
        // è¡¨å–®æäº¤
        const form = domUtils.query('#task-form', this.container);
        if (form) {
            eventUtils.on(form, 'submit', this.handleTaskCreate);
        }

        // æœç´¢
        const searchInput = domUtils.query('#task-search', this.container);
        if (searchInput) {
            eventUtils.on(searchInput, 'input', performanceUtils.debounce(this.handleSearch, 300));
        }

        // ç¯©é¸å™¨
        const filterButtons = domUtils.queryAll('.filter-btn', this.container);
        filterButtons.forEach(button => {
            eventUtils.on(button, 'click', () => {
                this.handleFilterChange(button.dataset.filter);
            });
        });

        // æ’åº
        const sortSelect = domUtils.query('#task-sort', this.container);
        if (sortSelect) {
            eventUtils.on(sortSelect, 'change', this.handleSort);
        }

        const sortOrderBtn = domUtils.query('#sort-order-btn', this.container);
        if (sortOrderBtn) {
            eventUtils.on(sortOrderBtn, 'click', () => {
                this.sortOrder = this.sortOrder === 'asc' ? 'desc' : 'asc';
                this.updateSortButton();
                this.renderTaskList();
            });
        }

        // æ‰¹é‡æ“ä½œ
        const clearCompletedBtn = domUtils.query('#clear-completed-btn', this.container);
        if (clearCompletedBtn) {
            eventUtils.on(clearCompletedBtn, 'click', this.handleClearCompleted);
        }

        const exportBtn = domUtils.query('#export-btn', this.container);
        if (exportBtn) {
            eventUtils.on(exportBtn, 'click', this.handleExport);
        }

        const importFile = domUtils.query('#import-file', this.container);
        if (importFile) {
            eventUtils.on(importFile, 'change', this.handleImport);
        }

        // ä»»å‹™åˆ—è¡¨äº‹ä»¶å§”è¨—
        const taskList = domUtils.query('#todo-list', this.container);
        if (taskList) {
            eventUtils.delegate(taskList, '.task-checkbox', 'click', (event) => {
                const taskId = event.target.closest('.task-item').dataset.id;
                this.handleTaskToggle(taskId);
            });

            eventUtils.delegate(taskList, '.task-edit-btn', 'click', (event) => {
                const taskId = event.target.closest('.task-item').dataset.id;
                this.handleStartEdit(taskId);
            });

            eventUtils.delegate(taskList, '.task-delete-btn', 'click', (event) => {
                const taskId = event.target.closest('.task-item').dataset.id;
                this.handleTaskDelete(taskId);
            });

            eventUtils.delegate(taskList, '.task-save-btn', 'click', (event) => {
                const taskId = event.target.closest('.task-item').dataset.id;
                this.handleSaveEdit(taskId);
            });

            eventUtils.delegate(taskList, '.task-cancel-btn', 'click', (event) => {
                this.handleCancelEdit();
            });
        }

        // éµç›¤å¿«æ·éµ
        eventUtils.on(document, 'keydown', (event) => {
            this.handleKeyboardShortcut(event);
        });
    }

    /**
     * ç¹«çµæœå‹™äº‹ä»¶
     */
    bindServiceEvents() {
        taskService.on(EVENT_TYPES.TODO_ADDED, (task) => {
            this.showNotification(SUCCESS_MESSAGES.TODO_ADDED, 'success');
            this.loadTasks();
        });

        taskService.on(EVENT_TYPES.TODO_UPDATED, (task) => {
            this.showNotification(SUCCESS_MESSAGES.TODO_UPDATED, 'success');
            this.loadTasks();
        });

        taskService.on(EVENT_TYPES.TODO_DELETED, (data) => {
            this.showNotification(SUCCESS_MESSAGES.TODO_DELETED, 'success');
            this.loadTasks();
        });

        taskService.on(EVENT_TYPES.TODO_COMPLETED, (task) => {
            this.showNotification('ä»»å‹™å·²å®Œæˆï¼', 'success');
            this.loadTasks();
        });

        taskService.on(EVENT_TYPES.SERVICE_ERROR, (data) => {
            this.showNotification(data.error.message || ERROR_MESSAGES.GENERIC, 'error');
        });
    }

    /**
     * è¼‰å…¥ä»»å‹™
     */
    async loadTasks() {
        try {
            this.setLoading(true);

            const filters = this.getFilters();
            this.tasks = await taskService.getAllTasks(filters);

            // æ‡‰ç”¨æœç´¢å’Œæ’åº
            let filteredTasks = this.tasks;
            if (this.searchTerm) {
                filteredTasks = await taskService.searchTasks(this.searchTerm, filters);
            }

            filteredTasks = this.sortTasks(filteredTasks);

            this.renderTaskList(filteredTasks);
            this.updateStats();

        } catch (error) {
            console.error('è¼‰å…¥ä»»å‹™å¤±æ•—:', error);
            this.showError('è¼‰å…¥å¤±æ•—', error.message);
        } finally {
            this.setLoading(false);
        }
    }

    /**
     * å–å¾—ç¯©é¸æ¢ä»¶
     */
    getFilters() {
        const filters = {};

        switch (this.currentFilter) {
            case 'active':
                filters.completed = false;
                break;
            case 'completed':
                filters.completed = true;
                break;
        }

        return filters;
    }

    /**
     * æ’åºä»»å‹™
     */
    sortTasks(tasks) {
        return [...tasks].sort((a, b) => {
            let comparison = 0;

            switch (this.sortBy) {
                case 'priority':
                    comparison = b.getPriorityValue() - a.getPriorityValue();
                    break;
                case 'title':
                    comparison = a.title.localeCompare(b.title);
                    break;
                case 'dueDate':
                    if (!a.dueDate && !b.dueDate) comparison = 0;
                    else if (!a.dueDate) comparison = 1;
                    else if (!b.dueDate) comparison = -1;
                    else comparison = a.dueDate - b.dueDate;
                    break;
                case 'updatedAt':
                    comparison = b.updatedAt - a.updatedAt;
                    break;
                case 'createdAt':
                default:
                    comparison = b.createdAt - a.createdAt;
                    break;
            }

            return this.sortOrder === 'asc' ? comparison : -comparison;
        });
    }

    /**
     * æ¸²æŸ“ä»»å‹™åˆ—è¡¨
     */
    renderTaskList(tasks = this.tasks) {
        const taskList = domUtils.query('#todo-list', this.container);
        const emptyState = domUtils.query('#empty-state', this.container);

        if (!taskList) return;

        // æ¸…ç©ºåˆ—è¡¨
        while (taskList.firstChild) {
            taskList.removeChild(taskList.firstChild);
        }

        if (tasks.length === 0) {
            if (emptyState) {
                emptyState.style.display = 'block';
            }
            return;
        }

        if (emptyState) {
            emptyState.style.display = 'none';
        }

        tasks.forEach(task => {
            const taskElement = this.createTaskElement(task);
            taskList.appendChild(taskElement);
        });
    }

    /**
     * å‰µå»ºä»»å‹™å…ƒç´ 
     */
    createTaskElement(task) {
        const isEditing = this.editingTaskId === task.id;
        const li = domUtils.createElement('li', {
            className: `task-item ${task.completed ? 'completed' : ''} ${isEditing ? 'editing' : ''} priority-${task.priority}`,
            'data-id': task.id,
            'data-completed': task.completed,
        });

        if (isEditing) {
            this.appendEditForm(li, task);
        } else {
            this.appendTaskContent(li, task);
        }

        return li;
    }

    /**
     * é™„åŠ ä»»å‹™å…§å®¹
     */
    appendTaskContent(element, task) {
        // æ ¸å–æ–¹å¡Š
        const checkbox = domUtils.createElement('div', {
            className: `task-checkbox ${task.completed ? 'checked' : ''}`,
            role: 'button',
            tabIndex: '0',
            'aria-label': task.completed ? 'æ¨™è¨˜ç‚ºæœªå®Œæˆ' : 'æ¨™è¨˜ç‚ºå·²å®Œæˆ',
            'aria-checked': task.completed,
        });
        element.appendChild(checkbox);

        // å…§å®¹å€åŸŸ
        const content = domUtils.createElement('div', { className: 'task-content' });

        // æ¨™é¡Œ
        const title = domUtils.createElement('h3', { className: 'task-title' });
        title.textContent = task.title;
        content.appendChild(title);

        // æè¿°
        if (task.description) {
            const description = domUtils.createElement('p', { className: 'task-description' });
            description.textContent = task.description;
            content.appendChild(description);
        }

        // å…ƒè³‡æ–™
        const meta = domUtils.createElement('div', { className: 'task-meta' });

        // å‰µå»ºæ™‚é–“
        const createdDate = domUtils.createElement('span', { className: 'task-date' });
        createdDate.textContent = dateUtils.getRelativeTime(task.createdAt);
        meta.appendChild(createdDate);

        // æˆªæ­¢æ—¥æœŸ
        if (task.dueDate) {
            const dueDate = domUtils.createElement('span', {
                className: `task-due-date ${task.isOverdue() ? 'overdue' : ''}`
            });
            dueDate.textContent = `æˆªæ­¢: ${dateUtils.formatDate(task.dueDate)}`;
            meta.appendChild(dueDate);
        }

        // å„ªå…ˆç´š
        const priority = domUtils.createElement('span', {
            className: `task-priority priority-${task.priority}`
        });
        priority.textContent = this.getPriorityLabel(task.priority);
        meta.appendChild(priority);

        // æ¨™ç±¤
        if (task.tags && task.tags.length > 0) {
            const tags = domUtils.createElement('div', { className: 'task-tags' });
            task.tags.forEach(tag => {
                const tagElement = domUtils.createElement('span', {
                    className: 'task-tag',
                    'data-tag': tag
                });
                tagElement.textContent = tag;
                tags.appendChild(tagElement);
            });
            meta.appendChild(tags);
        }

        content.appendChild(meta);
        element.appendChild(content);

        // æ“ä½œæŒ‰éˆ•
        const actions = domUtils.createElement('div', { className: 'task-actions' });

        const editBtn = domUtils.createElement('button', {
            className: 'task-action-btn task-edit-btn',
            'aria-label': 'ç·¨è¼¯ä»»å‹™',
            title: 'ç·¨è¼¯',
        });
        editBtn.textContent = 'âœï¸';
        actions.appendChild(editBtn);

        const deleteBtn = domUtils.createElement('button', {
            className: 'task-action-btn task-delete-btn',
            'aria-label': 'åˆªé™¤ä»»å‹™',
            title: 'åˆªé™¤',
        });
        deleteBtn.textContent = 'ğŸ—‘ï¸';
        actions.appendChild(deleteBtn);

        element.appendChild(actions);
    }

    /**
     * é™„åŠ ç·¨è¼¯è¡¨å–®
     */
    appendEditForm(element, task) {
        const form = domUtils.createElement('div', { className: 'task-edit-form' });

        // æ¨™é¡Œè¼¸å…¥
        const titleInput = domUtils.createElement('input', {
            type: 'text',
            className: 'task-edit-input',
            value: task.title,
            placeholder: 'ä»»å‹™æ¨™é¡Œ...',
            'aria-label': 'ç·¨è¼¯ä»»å‹™æ¨™é¡Œ',
            required: '',
            maxLength: '200',
        });
        form.appendChild(titleInput);

        // æè¿°è¼¸å…¥
        const descriptionInput = domUtils.createElement('textarea', {
            className: 'task-edit-textarea',
            placeholder: 'ä»»å‹™æè¿°...',
            'aria-label': 'ç·¨è¼¯ä»»å‹™æè¿°',
            rows: '3',
        });
        descriptionInput.value = task.description || '';
        form.appendChild(descriptionInput);

        // è¡¨æ ¼è¡Œ
        const formRow = domUtils.createElement('div', { className: 'form-row' });

        // å„ªå…ˆç´šé¸æ“‡
        const prioritySelect = domUtils.createElement('select', {
            className: 'task-edit-select',
            'aria-label': 'é¸æ“‡å„ªå…ˆç´š',
        });
        ['low', 'medium', 'high'].forEach(priority => {
            const option = domUtils.createElement('option', { value: priority });
            option.textContent = this.getPriorityLabel(priority);
            if (task.priority === priority) {
                option.selected = '';
            }
            prioritySelect.appendChild(option);
        });
        formRow.appendChild(prioritySelect);

        // æˆªæ­¢æ—¥æœŸ
        const dueDateInput = domUtils.createElement('input', {
            type: 'date',
            className: 'task-edit-date',
            'aria-label': 'æˆªæ­¢æ—¥æœŸ',
        });
        if (task.dueDate) {
            dueDateInput.value = dateUtils.formatDate(task.dueDate, 'YYYY-MM-DD');
        }
        formRow.appendChild(dueDateInput);

        // æ¨™ç±¤è¼¸å…¥
        const tagsInput = domUtils.createElement('input', {
            type: 'text',
            className: 'task-edit-input',
            value: task.tags ? task.tags.join(', ') : '',
            placeholder: 'æ¨™ç±¤ï¼ˆç”¨é€—è™Ÿåˆ†éš”ï¼‰...',
            'aria-label': 'ç·¨è¼¯ä»»å‹™æ¨™ç±¤',
        });
        formRow.appendChild(tagsInput);

        form.appendChild(formRow);

        // æ“ä½œæŒ‰éˆ•
        const actions = domUtils.createElement('div', { className: 'task-edit-actions' });

        const saveBtn = domUtils.createElement('button', {
            className: 'btn btn-primary task-save-btn',
            'aria-label': 'å„²å­˜ç·¨è¼¯',
        });
        saveBtn.textContent = 'å„²å­˜';
        actions.appendChild(saveBtn);

        const cancelBtn = domUtils.createElement('button', {
            className: 'btn btn-secondary task-cancel-btn',
            'aria-label': 'å–æ¶ˆç·¨è¼¯',
        });
        cancelBtn.textContent = 'å–æ¶ˆ';
        actions.appendChild(cancelBtn);

        form.appendChild(actions);
        element.appendChild(form);
    }

    /**
     * è™•ç†ä»»å‹™å‰µå»º
     */
    async handleTaskCreate(event) {
        event.preventDefault();

        try {
            const formData = this.getFormData();

            // é©—è­‰è³‡æ–™
            const validation = taskService.validateTaskData(formData);
            if (!validation.isValid) {
                this.showNotification(validation.errors.join(', '), 'error');
                return;
            }

            // å‰µå»ºä»»å‹™
            await taskService.createTask(validation.cleanedData);

            // æ¸…ç©ºè¡¨å–®
            this.clearForm();

            // èšç„¦åˆ°æ¨™é¡Œè¼¸å…¥æ¡†
            const titleInput = domUtils.query('#task-title', this.container);
            if (titleInput) {
                titleInput.focus();
            }

        } catch (error) {
            console.error('å‰µå»ºä»»å‹™å¤±æ•—:', error);
            this.showNotification(error.message, 'error');
        }
    }

    /**
     * è™•ç†ä»»å‹™åˆ‡æ›
     */
    async handleTaskToggle(taskId) {
        try {
            await taskService.toggleTaskComplete(taskId);
        } catch (error) {
            console.error('åˆ‡æ›ä»»å‹™ç‹€æ…‹å¤±æ•—:', error);
            this.showNotification(error.message, 'error');
        }
    }

    /**
     * è™•ç†ä»»å‹™åˆªé™¤
     */
    async handleTaskDelete(taskId) {
        try {
            const task = this.tasks.find(t => t.id === taskId);
            if (!task) return;

            if (!confirm(`ç¢ºå®šè¦åˆªé™¤ä»»å‹™ã€Œ${task.title}ã€å—ï¼Ÿ`)) {
                return;
            }

            await taskService.deleteTask(taskId);
        } catch (error) {
            console.error('åˆªé™¤ä»»å‹™å¤±æ•—:', error);
            this.showNotification(error.message, 'error');
        }
    }

    /**
     * è™•ç†é–‹å§‹ç·¨è¼¯
     */
    handleStartEdit(taskId) {
        // å¦‚æœå·²åœ¨ç·¨è¼¯å…¶ä»–ä»»å‹™ï¼Œå…ˆå–æ¶ˆ
        if (this.editingTaskId && this.editingTaskId !== taskId) {
            this.handleCancelEdit();
        }

        this.editingTaskId = taskId;
        this.renderTaskList();

        // èšç„¦åˆ°ç·¨è¼¯è¡¨å–®
        setTimeout(() => {
            const editInput = domUtils.query(`.task-item[data-id="${taskId}"] .task-edit-input`);
            if (editInput) {
                editInput.focus();
                editInput.select();
            }
        }, 0);
    }

    /**
     * è™•ç†å„²å­˜ç·¨è¼¯
     */
    async handleSaveEdit(taskId) {
        try {
            const taskElement = domUtils.query(`.task-item[data-id="${taskId}"]`);
            if (!taskElement) return;

            const formData = this.getEditFormData(taskElement);

            // é©—è­‰è³‡æ–™
            const validation = taskService.validateTaskData(formData, true);
            if (!validation.isValid) {
                this.showNotification(validation.errors.join(', '), 'error');
                return;
            }

            // æ›´æ–°ä»»å‹™
            await taskService.updateTask(taskId, validation.cleanedData);

            this.editingTaskId = null;
            this.renderTaskList();

        } catch (error) {
            console.error('å„²å­˜ç·¨è¼¯å¤±æ•—:', error);
            this.showNotification(error.message, 'error');
        }
    }

    /**
     * è™•ç†å–æ¶ˆç·¨è¼¯
     */
    handleCancelEdit() {
        this.editingTaskId = null;
        this.renderTaskList();
    }

    /**
     * è™•ç†ç¯©é¸è®Šæ›´
     */
    handleFilterChange(filter) {
        this.currentFilter = filter;

        // æ›´æ–°æŒ‰éˆ•ç‹€æ…‹
        const filterButtons = domUtils.queryAll('.filter-btn', this.container);
        filterButtons.forEach(button => {
            const isActive = button.dataset.filter === filter;
            button.classList.toggle('active', isActive);
            button.setAttribute('aria-selected', isActive);
        });

        this.loadTasks();
    }

    /**
     * è™•ç†æœç´¢
     */
    handleSearch(event) {
        this.searchTerm = event.target.value.trim();
        this.loadTasks();
    }

    /**
     * è™•ç†æ’åº
     */
    handleSort(event) {
        this.sortBy = event.target.value;
        this.loadTasks();
    }

    /**
     * è™•ç†æ¸…é™¤å·²å®Œæˆä»»å‹™
     */
    async handleClearCompleted() {
        try {
            const completedCount = this.tasks.filter(task => task.completed).length;

            if (completedCount === 0) {
                this.showNotification('æ²’æœ‰å·²å®Œæˆçš„ä»»å‹™', 'info');
                return;
            }

            if (!confirm(`ç¢ºå®šè¦æ¸…é™¤ ${completedCount} å€‹å·²å®Œæˆçš„ä»»å‹™å—ï¼Ÿ`)) {
                return;
            }

            const deletedCount = await taskService.deleteCompletedTasks();
            this.showNotification(`å·²æ¸…é™¤ ${deletedCount} å€‹å·²å®Œæˆçš„ä»»å‹™`, 'success');
        } catch (error) {
            console.error('æ¸…é™¤å·²å®Œæˆä»»å‹™å¤±æ•—:', error);
            this.showNotification(error.message, 'error');
        }
    }

    /**
     * è™•ç†åŒ¯å‡º
     */
    async handleExport() {
        try {
            const exportData = await taskService.exportTasks();
            const blob = new Blob([JSON.stringify(exportData, null, 2)], {
                type: 'application/json'
            });

            const url = URL.createObjectURL(blob);
            const a = domUtils.createElement('a', {
                href: url,
                download: `tasks_${new Date().toISOString().split('T')[0]}.json`,
            });
            a.click();
            URL.revokeObjectURL(url);

            this.showNotification('ä»»å‹™å·²åŒ¯å‡º', 'success');
        } catch (error) {
            console.error('åŒ¯å‡ºå¤±æ•—:', error);
            this.showNotification(error.message, 'error');
        }
    }

    /**
     * è™•ç†åŒ¯å…¥
     */
    async handleImport(event) {
        try {
            const file = event.target.files[0];
            if (!file) return;

            const text = await file.text();
            const importData = JSON.parse(text);

            const result = await taskService.importTasks(importData);

            if (result.success) {
                this.showNotification(
                    `æˆåŠŸåŒ¯å…¥ ${result.imported} å€‹ä»»å‹™${result.invalid > 0 ? `ï¼Œ${result.invalid} å€‹å¤±æ•—` : ''}`,
                    'success'
                );
                this.loadTasks();
            } else {
                this.showNotification('åŒ¯å…¥å¤±æ•—', 'error');
            }

            // æ¸…ç©ºæª”æ¡ˆè¼¸å…¥
            event.target.value = '';
        } catch (error) {
            console.error('åŒ¯å…¥å¤±æ•—:', error);
            this.showNotification('åŒ¯å…¥å¤±æ•—ï¼šæª”æ¡ˆæ ¼å¼éŒ¯èª¤', 'error');
            event.target.value = '';
        }
    }

    /**
     * è™•ç†éµç›¤å¿«æ·éµ
     */
    handleKeyboardShortcut(event) {
        // å¦‚æœæ­£åœ¨è¼¸å…¥ï¼Œä¸è™•ç†å¿«æ·éµ
        if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
            return;
        }

        const key = event.key.toLowerCase();
        const ctrl = event.ctrlKey || event.metaKey;

        if (ctrl && key === 'n') {
            event.preventDefault();
            const titleInput = domUtils.query('#task-title', this.container);
            if (titleInput) {
                titleInput.focus();
            }
        }
    }

    /**
     * å–å¾—è¡¨å–®è³‡æ–™
     */
    getFormData() {
        const titleInput = domUtils.query('#task-title', this.container);
        const descriptionInput = domUtils.query('#task-description', this.container);
        const prioritySelect = domUtils.query('#task-priority', this.container);
        const dueDateInput = domUtils.query('#task-due-date', this.container);
        const tagsInput = domUtils.query('#task-tags', this.container);

        const tags = tagsInput?.value
            .split(',')
            .map(tag => tag.trim().toLowerCase())
            .filter(tag => tag.length > 0) || [];

        return {
            title: titleInput?.value?.trim() || '',
            description: descriptionInput?.value?.trim() || '',
            priority: prioritySelect?.value || 'medium',
            dueDate: dueDateInput?.value ? new Date(dueDateInput.value) : null,
            tags,
        };
    }

    /**
     * å–å¾—ç·¨è¼¯è¡¨å–®è³‡æ–™
     */
    getEditFormData(taskElement) {
        const titleInput = domUtils.query('.task-edit-input', taskElement);
        const descriptionInput = domUtils.query('.task-edit-textarea', taskElement);
        const prioritySelect = domUtils.query('.task-edit-select', taskElement);
        const dueDateInput = domUtils.query('.task-edit-date', taskElement);
        const tagsInput = domUtils.query('.form-row .task-edit-input', taskElement);

        const tags = tagsInput?.value
            .split(',')
            .map(tag => tag.trim().toLowerCase())
            .filter(tag => tag.length > 0) || [];

        return {
            title: titleInput?.value?.trim() || '',
            description: descriptionInput?.value?.trim() || '',
            priority: prioritySelect?.value || 'medium',
            dueDate: dueDateInput?.value ? new Date(dueDateInput.value) : null,
            tags,
        };
    }

    /**
     * æ¸…ç©ºè¡¨å–®
     */
    clearForm() {
        const form = domUtils.query('#task-form', this.container);
        if (form) {
            form.reset();
        }
    }

    /**
     * æ›´æ–°çµ±è¨ˆè³‡è¨Š
     */
    async updateStats() {
        try {
            const stats = await taskService.getTaskStats();

            const elements = {
                total: domUtils.query('#stat-total', this.container),
                active: domUtils.query('#stat-active', this.container),
                completed: domUtils.query('#stat-completed', this.container),
                overdue: domUtils.query('#stat-overdue', this.container),
            };

            if (elements.total) elements.total.textContent = stats.total;
            if (elements.active) elements.active.textContent = stats.active;
            if (elements.completed) elements.completed.textContent = stats.completed;
            if (elements.overdue) elements.overdue.textContent = stats.overdue;

        } catch (error) {
            console.error('æ›´æ–°çµ±è¨ˆå¤±æ•—:', error);
        }
    }

    /**
     * æ›´æ–°æ’åºæŒ‰éˆ•
     */
    updateSortButton() {
        const sortOrderBtn = domUtils.query('#sort-order-btn', this.container);
        if (sortOrderBtn) {
            const icon = domUtils.query('.sort-icon', sortOrderBtn);
            if (icon) {
                icon.textContent = this.sortOrder === 'asc' ? 'â†‘' : 'â†“';
            }
        }
    }

    /**
     * è¨­å®šè¼‰å…¥ç‹€æ…‹
     */
    setLoading(isLoading) {
        this.isLoading = isLoading;
        const loadingIndicator = domUtils.query('#loading-indicator', this.container);
        if (loadingIndicator) {
            loadingIndicator.style.display = isLoading ? 'flex' : 'none';
        }
    }

    /**
     * å–å¾—å„ªå…ˆç´šæ¨™ç±¤
     */
    getPriorityLabel(priority) {
        const labels = {
            low: 'ä½',
            medium: 'ä¸­',
            high: 'é«˜',
        };
        return labels[priority] || priority;
    }

    /**
     * é¡¯ç¤ºé€šçŸ¥
     */
    showNotification(message, type = 'info') {
        const container = domUtils.query('#notification-container', this.container);
        if (!container) return;

        const notification = domUtils.createElement('div', {
            className: `notification ${type}`,
            role: 'alert',
            'aria-live': 'polite',
        });

        const icon = this.getNotificationIcon(type);
        notification.appendChild(icon);

        const text = domUtils.createElement('span', { className: 'notification-text' });
        text.textContent = message;
        notification.appendChild(text);

        const closeBtn = domUtils.createElement('button', {
            className: 'notification-close',
            'aria-label': 'é—œé–‰é€šçŸ¥',
        });
        closeBtn.textContent = 'Ã—';
        closeBtn.addEventListener('click', () => {
            notification.remove();
        });
        notification.appendChild(closeBtn);

        container.appendChild(notification);

        // è‡ªå‹•ç§»é™¤
        setTimeout(() => {
            if (notification.parentNode) {
                notification.remove();
            }
        }, APP_CONFIG.ui.notifications.duration || 5000);

        // é™åˆ¶é€šçŸ¥æ•¸é‡
        this.limitNotifications();
    }

    /**
     * å–å¾—é€šçŸ¥åœ–ç¤º
     */
    getNotificationIcon(type) {
        const icons = {
            success: 'âœ…',
            error: 'âŒ',
            warning: 'âš ï¸',
            info: 'â„¹ï¸',
        };
        const icon = domUtils.createElement('span', { className: 'notification-icon' });
        icon.textContent = icons[type] || 'â„¹ï¸';
        return icon;
    }

    /**
     * é™åˆ¶é€šçŸ¥æ•¸é‡
     */
    limitNotifications() {
        const container = domUtils.query('#notification-container', this.container);
        if (!container) return;

        const maxCount = APP_CONFIG.ui.notifications.maxCount || 5;
        const notifications = container.children;

        while (notifications.length > maxCount) {
            notifications[0].remove();
        }
    }

    /**
     * é¡¯ç¤ºéŒ¯èª¤
     */
    showError(title, message) {
        this.showNotification(`${title}: ${message}`, 'error');
    }

    /**
     * éŠ·æ¯€ä»»å‹™ç®¡ç†å™¨
     */
    dispose() {
        this.editingTaskId = null;
        this.tasks = [];

        if (taskService.dispose) {
            taskService.dispose();
        }

        console.log('TaskManager å·²éŠ·æ¯€');
    }
}

export default TaskManager;